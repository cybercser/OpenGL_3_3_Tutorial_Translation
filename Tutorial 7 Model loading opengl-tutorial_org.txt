Tutorial 7 : Model loading
模型加载

目前为止，我们一直在硬编码描述立方体。你一定觉得这样做很笨拙、不方便。

本课将学习从文件中加载3D模型。和加载纹理类似，我们先写一个小的、功能有限的加载器，接着再为大家介绍几个比我们写的更好的、实用的库。

为了让课程尽可能简单，我们将采用简单、常用的OBJ格式。同样也是出于简单原则，我们只处理每个顶点有一个UV坐标和一个法向量的OBJ文件（目前你不需要知道什么是法向量）。

加载OBJ模型
加载函数在common/objloader.hpp中声明，在common/objloader.cpp中实现。函数原型如下：

我们让loadOBJ读取文件路径，把数据写入out_vertices/out_uvs/out_normals。如果出错则返回false。std::vector是C++中的数组，可存放glm::vec3类型的数据，数组大小可任意修改，不过std::vector和数学中的向量（vector）是两码事。其实它只是个数组。最后提一点，符号&意思是这个函数将会直接修改这些数组。

OBJ文件示例
OBJ文件看起来大概像这样：

因此：
#是注释标记，就像C++中的//
usemtl和mtlib描述了模型的外观。本课用不到。
v代表顶点
vt代表顶点的纹理坐标
vn代表顶点的法向
f代表面

v vt vn都很好理解。f比较麻烦。例如f 8/11/7 7/12/7 6/10/7：
8/11/7描述了三角形的第一个顶点
7/12/7描述了三角形的第二个顶点
6/10/7描述了三角形的第三个顶点
对于第一个顶点，8指向要用的顶点。此例中是-1.000000 1.000000 -1.000000（索引从1开始，和C++中从0开始不同）
11指向要用的纹理坐标。此例中是0.748355 0.998230。
7指向要用的法向。此例中是0.000000 1.000000 -0.000000。

我们称这些数字为索引。若几个顶点共用同一个坐标，索引就显得很方便，文件中只需保存一个“V”，可以多次引用，节省了存储空间。

不好的地方在于，我们不能让OpenGL混用顶点、纹理和法向索引。因此本课采用的方法是创建一个标准的、未加索引的模型。等第九课时再讨论索引，届时将会介绍如何解决OpenGL的索引问题。

用Blender创建OBJ文件
我们写的蹩脚加载器功能实在有限，因此在导出模型时得格外小心。下图展示了在Blender中导出模型的情形：

读取OBJ文件
OK，真正开始编码了。需要一些临时变量存储.obj文件的内容。

学第五课纹理立方体时，你已学会如何打开文件了：

读文件直到文件末尾：

（注意，我们假设第一行的文字长度不超过128，这样做太愚蠢了。但既然这只是个实验品，就凑合一下吧）

首先处理顶点：

也就是说，若第一个字是“v”，则后面一定是3个float值，于是以这3个值创建一个glm::vec3变量，将其添加到数组。

也就是说，如果不是“v”而是“vt”，那后面一定是2个float值，于是以这2个值创建一个glm::vec2变量，添加到数组。

以同样的方式处理法向：

接下来是“f”，略难一些：

代码与前面的类似，只不过读取的数据多一些。

处理数据
我们只需改变一下数据的形式。读取的是字符串，现在有了一组数组。这还不够，我们得把数据组织成OpenGL要求的形式。也就是去掉索引，只保留顶点坐标数据。这步操作称为索引。

遍历每个三角形（每个“f”行）的每个顶点（每个 v/vt/vn）：

顶点坐标的索引存放到vertexIndices[i]：

因此坐标是temp_vertices[ vertexIndex-1 ]（-1是因为C++的下标从0开始，而OBJ的索引从1开始，还记得吗？）：

这样就有了一个顶点坐标：

UV和法向同理，任务完成！

使用加载的数据
到这一步，几乎什么变化都没发生。这次我们不再声明一个static const GLfloat g_vertex_buffer_data[] = {…}，而是创建一个顶点数组（UV和法向同理）。用正确的参数调用loadOBJ：

把数组传给OpenGL：

结束了！

结果
不好意思，纹理不好看。我不太擅长美工。欢迎您来提供一些好的纹理。

其他模型格式及加载器
这个小巧的加载器应该比较适合初学，不过别在实际中使用它。参考一下实用链接和工具页面，看看有什么能用的。不过请注意，等到第九课才会真正用到这些工具。
