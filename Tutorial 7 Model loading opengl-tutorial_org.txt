Tutorial 7 : Model loading
模型加载

目前为止，我们都是把立方体信息直接硬编码在代码里。相信你一定也觉得这样做很笨拙、不方便。

本课将学习从文件中加载三维模型。和讲加载纹理时类似，我们先写一个小的、功能有限的加载器；接着再为大家介绍几个比我们写得更好的、实用的库。

为了让课程尽可能简单，我们将介绍简单、常用的OBJ格式。同样出于简单原则，我们仅处理每个顶点只含一个UV坐标和一个法向量的OBJ文件（目前你不需要知道什么是法向量）。

加载OBJ模型
函数声明在common/objloader.hpp中，实现在common/objloader.cpp中。函数原型如下：

我们想让loadOBJ读取文件路径，把数据写入out_vertices/out_uvs/out_normals；如果出错则返回false。std::vector是C++中可存放glm::vec3数据的可变长数组：它和数学中的向量（vector）是两码事，它就是个数组。最后，『&』的意思是函数将能够修改这些数组。

OBJ文件示例
OBJ文件看起来大概像这样：

因此：
#是注释标记，就像C++中的//
usemtl和mtlib描述了模型的外观。本课用不到。
v代表顶点坐标
vt代表顶点的纹理坐标
vn代表顶点的法向
f代表面

v vt vn都很好理解。f比较麻烦。例如f 8/11/7 7/12/7 6/10/7：
8/11/7描述三角形的第一个顶点
7/12/7描述三角形的第二个顶点
6/10/7描述三角形的第三个顶点
对于第一个顶点，8指明顶点的坐标。本例中是-1.000000 1.000000 -1.000000（从1开始索引，和C++中从0开始不同）
11指明顶点的纹理坐标。本例中是0.748355 0.998230。
7指明顶点的法向。本例中是0.000000 1.000000 -0.000000。

我们称这些数字为索引。索引非常好用，比如多个顶点共用同一个坐标，文件中只需保存一个“V”，就可以多次引用，节省存储空间。

坏消息是：OpenGL中指定面的顶点、纹理和法向时，不能用上面这种指定索引的方式。因此本课采用的方法是创建一个标准的、非索引的模型；等第九课时再讨论索引，届时将会介绍解决方法。

用Blender创建OBJ文件
我们写的蹩脚加载器功能实在有限，因此在导出模型时得格外小心。下图展示了在Blender中导出模型的情形：

读取OBJ文件
OK，真正开始写代码。需要一些临时变量存储.obj文件的内容。

学第五课纹理方块时，你已学会如何打开文件了：

读文件直到文件末尾：

（注意，我们假设第一行的文字长度不超过128，这个假设很傻。但这只是个实验品，就凑合一下吧）

首先处理顶点：

即：若第一个字是“v”，则后面一定是3个float值，就用这3个值创建一个glm::vec3变量，将它添加到数组。

即：如果不是“v”而是“vt”，那后面一定是2个float值，就用这2个值创建一个glm::vec2变量，添加到数组。

以同样的方式处理法向：

接下来是“f”，略难一些：

代码与前面类似，只不过读取的数据多一些。

处理数据
我们一直都是在改变数据的形式。我们读字符串，现在生成了一些数组。这还不够，我们得把数据组织成OpenGL的形式。也就是去掉索引，转成glm::vec3数组。这步操作称为检索（indexing）。

遍历每个三角形（每个“f”行）的每个顶点（每个 v/vt/vn）：

顶点坐标的索引在vertexIndices[i]中：

所以坐标是temp_vertices[ vertexIndex-1 ]（减1是因为C++的下标从0开始，而OBJ的索引从1开始，还记得吗？）：

这样就有了一个顶点坐标：

UV和法向同理，任务完成！

使用加载的数据
到这一步，就没什么不同了。这次我们不再声明一个static const GLfloat g_vertex_buffer_data[] = {…}，而是创建一个std::vector顶点数组（法向和UV同理）。用正确的参数调用loadOBJ：

把数组传给OpenGL：

结束了！

结果
不好意思，纹理不好看。我不是个好艺术家，欢迎您提供一些好的纹理。

其他模型格式及加载器
这个小巧的加载器应该比较适合初学，不过别去实际使用它。参考一下实用链接和工具页面，看看有什么能用的。不过请注意，等到第九课才会真正用到这些工具。
