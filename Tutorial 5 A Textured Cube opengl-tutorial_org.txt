Tutorial 5 : A Textured Cube
第五课：纹理方块
关于UV坐标
自己加载.BMP图片
在OpenGL中使用纹理
什么是滤波和多级纹理（Mipmaps）？怎样使用？
	线性滤波（Linear filtering）
	各向异性滤波（Anisotropic filtering）
	多级纹理（Mipmaps）
怎样用GLFW加载纹理？
压缩纹理
	创建压缩纹理
	使用压缩纹理
	反转UV坐标
总结
练习
参考文献

本课你将学到：
什么是UV坐标
怎样自己加载纹理
怎样在OpenGL中使用纹理
什么是滤波和多级纹理（mipmap）？怎样使用？
怎样用GLFW更健壮地加载纹理？
什么是透明通道？

关于UV坐标
给网格贴纹理时，需要以某种方式告诉OpenGL，每个三角形用哪块纹理来填充。这是用UV坐标实现的。

除了位置，顶点都还有两个浮点型的坐标：U和V。这两个坐标用于获取纹理，如下图：

注意纹理是怎样在三角形上形变的。

自己加载.BMP图片
了解BMP文件格式不重要：很多库可以帮你做解析。但BMP格式很简单，了解它又能帮你理解底层机制；所以，我们从零开始写一个BMP文件加载器，方便你理解工作原理，之后就不再用它了。

如下是加载函数的声明：

使用方式如下：

接下来看看如何读取BMP文件。

首先需要一些数据。读取文件时将设置这些变量。

现在正式开始打开文件。

文件的开始是54字节的头部，用于标识：“这是不是BMP文件？”、图像大小、每像素的比特位数等。来读取文件头吧：

头部总以“BM”为起始。实际上，如果用十六进制编辑器打开BMP文件，你会看到：

因此，必须检查头两个字节是不是‘B’和‘M’：

现在可以读取文件中图像大小、数据位置等信息了：

如有缺失，得手动补齐：

现在图像大小已知，可以分配一些内存，把图像读进去：

到真正OpenGL的部分了。创建纹理和创建顶点缓冲区差不多：
创建一个纹理、绑定之、填充之、配置之。

在glTexImage2D中，GL_RGB表示颜色由三个分量构成，GL_BGR指明颜色值在内存中的存储方式。实际上，BMP的存储方式不是红R->绿G->蓝B，而是蓝B->绿G->红R，必须把这点告诉OpenGL。

稍后再解释最后两行代码。同时，在C++这边，你可以用写好的函数加载纹理了：

另外十分重要的一点：用2次幂大小的纹理！
	好的：128*128、256*256、1024*1024、2*2……
	坏的：127*128、3*5
	勉强，但很怪异：128*256

在OpenGL中使用纹理
先来看看片断着色器。大部分代码一目了然：

注意三点：
	片断着色器需要UV坐标。很合理。
	它还需要一个“sampler2D ”来确定要加载哪一个纹理（一个着色器可以访问多个纹理）
	最后，用texture()访问纹理；该方法返回一个(R,G,B,A)的vec4变量。下面很快就讲解分量A。

顶点着色器也很简单，只需把UV坐标传给片断着色器：

还记得第四课的“layout(location = 1) in vec2 vertexUV”吗？我们现在要做同样的事，但这次，缓冲区放的不是(R,G,B)三元组，而是(U,V)数对。

上述UV坐标对应下面的模型：

其余就很清楚了。创建缓冲区、绑定、填充、配置，一样地绘制顶点缓冲区。要注意把glVertexAttribPointer的第二个参数（大小）由3改成2。

结果如下：

放大后：

什么是滤波和多级纹理（mipmap）？怎样使用？
正如上面截图中所示，纹理质量不是很好。这是因为在loadBMP_custom中，我们写道：

这表示在片断着色器中，texture()提取(U,V)坐标处的纹素（texel）后，没做任何处理。
我们有若干改进方法。

线性滤波
线性滤波时，texture()会查看周围的纹素，根据它们的中心到目标点的距离，来混合颜色。这就消除了前面的边缘锯齿。
线性滤波效果不错，应用广泛；若想要更高的质量，可以用速度略慢的各向异性滤波。

各向异性滤波
该方法试图近似片断中真正可见纹理块。例如，若对下图的纹理稍加旋转，并从侧面观察，则各向异性滤波将沿蓝色矩形框的主方向，作若干（即“各向异性层级”）采样，算出框内颜色。

多级纹理（Mipmaps）
线性滤波和各向异性滤波都存在一个共同问题。比如从远处观察纹理，只对4个纹素作混合显然不够。实际上，如果三维模型距离很远，在屏幕上只占一个片断（像素），那计算最终颜色时，应该拿图像的全部纹素来求均值。显然，这样做没有考虑性能。于是，人们引入了多级纹理：
开始，把图像缩小一半；接着一级级做下去，直到图像只有1x1大小（应该是图像所有纹素的均值）
绘制网格时，根据纹素大小，选择合适的那级纹理。
采样方法可以用：取最近纹素（译注：最开始提到的）、线性或各向异性滤波。
想效果更好，可取两级纹理做采样，然后混合，得出结果。
很幸运，做这些都很简单，OpenGL帮我们全实现好了，只需简单地调用：


怎样利用GLFW加载纹理？
我们的loadBMP_custom函数很棒，因为是我们自己写的；不过用专门的库更好，GLFW就可以（仅限TGA文件）：

压缩纹理
学到这儿，你可能在想，怎样加载JPEG文件而不是TGA文件呢？
简单的说：别这么干。有更好的选择。

创建压缩纹理
下载The Compressonator，一款ATI工具
用它加载一个二次幂纹理
将纹理压成DXT1、DXT3或DXT5（这些格式的差别，参考维基百科）：
生成多级纹理，这样就不必在运行时做计算了。
导出为.DDS文件。

至此，图像已被压缩成GPU直接可用的格式。着色器中，任何时候调用texture()均可实时解压。
解压看似很慢，但由于它节省了很多内存，数据传输量就少了。内存数据传输开销很大；纹理解压却是零开销（有专门硬件负责）。一般情况下，压缩纹理可使性能提升20%。
	
使用压缩纹理
来看看怎样加载压缩纹理。这和BMP的代码很相似，只不过文件头的结构不一样：

文件头后是真正的数据：顺序存着多级纹理的每个层级。可以一次性全部读取：

这里要处理三种格式：DXT1、DXT3和DXT5。我们得把“fourCC”标识转换成OpenGL能识别的值。

像往常一样创建纹理：

现在只需逐级填充多级纹理：

反转UV坐标
DXT压缩源自DirectX。相比OpenGL，DirectX中的V坐标是反的。故压缩纹理时，得用(coord.v, 1.0-coord.v)获取正确纹素。这步操作何时做都可以：在导出脚本中、在加载器中、
在着色器中……

总结
刚刚学习了在OpenGL中创建、加载及使用纹理。
总的来说，你应该只用压缩纹理：它体积小、加载快、性能好；主要的缺点是：得用The Compressonator来转格式。

练习
源码中实现了DDS加载器，但没做纹理坐标反转。在适当的位置添加该功能，使正方体正确显示。
试试各种DDS格式。所得结果有何不同？压缩率呢？
试试不在The Compressonator中合成多级纹理。结果如何？给出3种不同解决方案。


参考文献
Using texture compression in OpenGL , Sébastien Domine, NVIDIA
